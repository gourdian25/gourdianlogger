<!-- File: test_coverage/benchmark_coverage.html -->

<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>gourdianlogger: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/gourdian25/gourdianlogger/gourdianlogger.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// File: gourdianlogger.go

package gourdianlogger

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "runtime"
        "sort"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "golang.org/x/time/rate"
)

// LogLevel represents the severity level of a log message.
// The levels are ordered from least to most severe:
// DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL.
type LogLevel int32

// Constants defining the available log levels.
const (
        DEBUG LogLevel = iota // Debug-level messages for development
        INFO                  // Informational messages about normal operation
        WARN                  // Warning messages about potential issues
        ERROR                 // Error messages about problems that need attention
        FATAL                 // Fatal messages about critical errors that force shutdown
)

// LogFormat represents the format in which logs will be written.
type LogFormat int

// Constants defining available log formats.
const (
        FormatPlain LogFormat = iota // Plain text format (human-readable)
        FormatJSON                   // JSON format (machine-readable)
)

var (
        defaultBackupCount           = 5
        defaultBufferSize            = 0
        defaultAsyncWorkers          = 1
        defaultMaxLogRate            = 0
        defaultEnableCaller          = true
        defaultEnableFallback        = true
        defaultLogsDir               = "logs"
        defaultLogLevel              = DEBUG
        defaultLogFormat             = FormatPlain
        defaultFileName              = "gourdianlogs"
        defaultMaxBytes        int64 = 10 * 1024 * 1024
        defaultTimestampFormat       = "2006-01-02 15:04:05.000000"
)

// LoggerConfig contains configuration options for the logger.
// All fields have sensible defaults and are optional.
type LoggerConfig struct {
        BackupCount     int                    `json:"backup_count"`     // Number of backup log files to keep (default: 5)
        BufferSize      int                    `json:"buffer_size"`      // Size of the async buffer in messages (0 for synchronous logging, default: 0)
        AsyncWorkers    int                    `json:"async_workers"`    // Number of async worker goroutines (default: 1)
        MaxLogRate      int                    `json:"max_log_rate"`     // Maximum number of logs per second (0 for no limit, default: 0)
        EnableCaller    bool                   `json:"enable_caller"`    // Whether to include caller information (file:line:function) (default: true)
        EnableFallback  bool                   `json:"enable_fallback"`  // Whether to fallback to stderr when logging fails (default: true)
        PrettyPrint     bool                   `json:"pretty_print"`     // Pretty-print JSON logs (only applies to JSON format, default: false)
        MaxBytes        int64                  `json:"max_bytes"`        // Maximum size in bytes before rotating log file (default: 10MB)
        Filename        string                 `json:"filename"`         // Base filename for logs (without extension, default: "gourdianlogs")
        TimestampFormat string                 `json:"timestamp_format"` // Timestamp format (default: "2006-01-02 15:04:05.000000")
        LogsDir         string                 `json:"logs_dir"`         // Directory to store log files (default: "logs")
        FormatStr       string                 `json:"format"`           // Format string ("PLAIN" or "JSON", default: "PLAIN")
        LogLevel        LogLevel               `json:"log_level"`        // Default log level (default: DEBUG)
        CustomFields    map[string]interface{} `json:"custom_fields"`    // Custom fields to include in every log message (JSON format only)
        Outputs         []io.Writer            `json:"-"`                // Additional output writers (e.g., network connections, other files)
        LogFormat       LogFormat              `json:"-"`                // Log format (overrides FormatStr if set)
        ErrorHandler    func(error)            `json:"-"`                // Error handler function for logging errors
}

// Logger is the main logging struct that provides all logging functionality.
// It should be created using NewGourdianLogger() or NewDefaultGourdianLogger().
type Logger struct {
        fileMu          sync.Mutex
        outputsMu       sync.RWMutex
        level           atomic.Int32
        baseFilename    string
        maxBytes        int64
        backupCount     int
        file            *os.File
        multiWriter     io.Writer
        timestampFormat string
        outputs         []io.Writer
        logsDir         string
        closed          atomic.Bool
        rotateChan      chan struct{}
        rotateCloseChan chan struct{}
        wg              sync.WaitGroup
        enableCaller    bool
        asyncQueue      chan *bytes.Buffer
        asyncCloseChan  chan struct{}
        asyncWorkers    int
        format          LogFormat
        fallbackWriter  io.Writer
        errorHandler    func(error)
        rateLimiter     *rate.Limiter
        config          LoggerConfig
        dynamicLevelFn  func() LogLevel
        paused          atomic.Bool
        bufferPool      sync.Pool
}

func (l LogLevel) String() string <span class="cov0" title="0">{
        switch l </span>{
        case DEBUG:<span class="cov0" title="0">
                return "DEBUG"</span>
        case INFO:<span class="cov0" title="0">
                return "INFO"</span>
        case WARN:<span class="cov0" title="0">
                return "WARN"</span>
        case ERROR:<span class="cov0" title="0">
                return "ERROR"</span>
        case FATAL:<span class="cov0" title="0">
                return "FATAL"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// ParseLogLevel converts a string representation of a log level to a LogLevel constant.
// Valid strings (case-insensitive): "DEBUG", "INFO", "WARN"/"WARNING", "ERROR", "FATAL".
//
// Example:
//
//        level, err := ParseLogLevel("info") // Returns INFO, nil
//        if err != nil {
//            // handle error
//        }
func ParseLogLevel(level string) (LogLevel, error) <span class="cov0" title="0">{
        switch strings.ToUpper(level) </span>{
        case "DEBUG":<span class="cov0" title="0">
                return DEBUG, nil</span>
        case "INFO":<span class="cov0" title="0">
                return INFO, nil</span>
        case "WARN", "WARNING":<span class="cov0" title="0">
                return WARN, nil</span>
        case "ERROR":<span class="cov0" title="0">
                return ERROR, nil</span>
        case "FATAL":<span class="cov0" title="0">
                return FATAL, nil</span>
        default:<span class="cov0" title="0">
                return DEBUG, fmt.Errorf("invalid log level: %s", level)</span>
        }
}

// NewGourdianLogger creates a new Logger with the specified configuration.
// The configuration is validated and sensible defaults are applied for any missing values.
//
// Default values used when not specified in config:
//   - Filename: "gourdianlogs" (without .log extension)
//   - MaxBytes: 10MB (10 * 1024 * 1024)
//   - BackupCount: 5 (keep 5 rotated log files)
//   - LogLevel: DEBUG (log all levels)
//   - TimestampFormat: "2006-01-02 15:04:05.000000" (microsecond precision)
//   - LogsDir: "logs" (directory where log files are stored)
//   - EnableCaller: true (include caller information)
//   - BufferSize: 0 (synchronous logging)
//   - AsyncWorkers: 1 (if BufferSize &gt; 0)
//   - LogFormat: FormatPlain (plain text format)
//   - EnableFallback: true (fallback to stderr on errors)
//   - MaxLogRate: 0 (no rate limiting)
//
// The function performs the following operations:
//  1. Validates the configuration
//  2. Applies defaults for missing values
//  3. Creates the log directory if it doesn't exist
//  4. Opens/Creates the log file
//  5. Initializes all logger components
//  6. Starts background workers if needed
//
// Example with custom configuration:
//
//        config := gourdianlogger.LoggerConfig{
//            Filename: "myapp",                // Creates myapp.log
//            LogsDir: "var/logs",              // Stores logs in var/logs/
//            MaxBytes: 20 * 1024 * 1024,       // 20MB rotation size
//            BackupCount: 10,                  // Keep 10 rotated logs
//            LogLevel: gourdianlogger.INFO,    // Only log INFO and above
//            AsyncWorkers: 4,                  // Use 4 async workers
//            BufferSize: 1000,                 // Buffer up to 1000 messages
//            EnableCaller: false,              // Disable caller info
//            LogFormat: gourdianlogger.FormatJSON, // JSON format
//            MaxLogRate: 1000,                 // Limit to 1000 logs/second
//            CustomFields: map[string]interface{}{
//                "app": "myapp",
//                "version": "1.0.0",
//            },
//        }
//
//        logger, err := gourdianlogger.NewGourdianLogger(config)
//        if err != nil {
//            panic(fmt.Errorf("failed to create logger: %w", err))
//        }
//        defer logger.Close()
//
//        // Usage:
//        logger.Info("Application started")
//        logger.Debugf("Config loaded: %+v", config) // Won't be logged due to INFO level
func NewGourdianLogger(config LoggerConfig) (*Logger, error) <span class="cov0" title="0">{
        if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid config: %w", err)
        }</span>

        // Set defaults
        <span class="cov0" title="0">if config.MaxBytes &lt;= 0 </span><span class="cov0" title="0">{
                config.MaxBytes = defaultMaxBytes
        }</span>
        <span class="cov0" title="0">if config.BackupCount &lt;= 0 </span><span class="cov0" title="0">{
                config.BackupCount = defaultBackupCount
        }</span>
        <span class="cov0" title="0">if config.TimestampFormat == "" </span><span class="cov0" title="0">{
                config.TimestampFormat = defaultTimestampFormat
        }</span>
        <span class="cov0" title="0">if config.LogsDir == "" </span><span class="cov0" title="0">{
                config.LogsDir = defaultLogsDir
        }</span>
        <span class="cov0" title="0">if config.Filename == "" </span><span class="cov0" title="0">{
                config.Filename = "gourdianlogs"
        }</span>
        <span class="cov0" title="0">if config.AsyncWorkers &lt;= 0 &amp;&amp; config.BufferSize &gt; 0 </span><span class="cov0" title="0">{
                config.AsyncWorkers = 1
        }</span>

        <span class="cov0" title="0">config.Filename = strings.TrimSpace(strings.TrimSuffix(config.Filename, ".log"))
        if err := os.MkdirAll(config.LogsDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create log directory: %w", err)
        }</span>

        <span class="cov0" title="0">logPath := filepath.Join(config.LogsDir, config.Filename+".log")
        file, err := os.OpenFile(logPath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open log file: %w", err)
        }</span>

        <span class="cov0" title="0">outputs := []io.Writer{file, os.Stdout}
        if config.Outputs != nil </span><span class="cov0" title="0">{
                outputs = append(outputs, config.Outputs...)
        }</span>
        <span class="cov0" title="0">validOutputs := make([]io.Writer, 0, len(outputs))
        for _, w := range outputs </span><span class="cov0" title="0">{
                if w != nil </span><span class="cov0" title="0">{
                        validOutputs = append(validOutputs, w)
                }</span>
        }

        <span class="cov0" title="0">logger := &amp;Logger{
                baseFilename:    logPath,
                maxBytes:        config.MaxBytes,
                backupCount:     config.BackupCount,
                file:            file,
                timestampFormat: config.TimestampFormat,
                outputs:         validOutputs,
                logsDir:         config.LogsDir,
                rotateChan:      make(chan struct{}, 1),
                rotateCloseChan: make(chan struct{}),
                enableCaller:    config.EnableCaller,
                asyncWorkers:    config.AsyncWorkers,
                format:          config.LogFormat,
                errorHandler:    config.ErrorHandler,
                config:          config,
                bufferPool: sync.Pool{
                        New: func() interface{} </span><span class="cov0" title="0">{
                                return bytes.NewBuffer(make([]byte, 0, 256))
                        }</span>,
                },
        }

        <span class="cov0" title="0">if config.EnableFallback </span><span class="cov0" title="0">{
                logger.fallbackWriter = os.Stderr
        }</span>

        // In NewGourdianLogger(), change the rate limiter initialization to:
        <span class="cov0" title="0">if config.MaxLogRate &gt; 0 </span><span class="cov0" title="0">{
                // Set burst size to 1 to enforce strict rate limiting
                logger.rateLimiter = rate.NewLimiter(rate.Limit(config.MaxLogRate), 1)
        }</span>

        <span class="cov0" title="0">logger.level.Store(int32(config.LogLevel))
        logger.multiWriter = io.MultiWriter(validOutputs...)

        logger.wg.Add(1)
        go logger.fileSizeRotationWorker()

        if config.BufferSize &gt; 0 </span><span class="cov0" title="0">{
                logger.asyncQueue = make(chan *bytes.Buffer, config.BufferSize)
                logger.asyncCloseChan = make(chan struct{})
                for i := 0; i &lt; logger.asyncWorkers; i++ </span><span class="cov0" title="0">{
                        logger.wg.Add(1)
                        go logger.asyncWorker()
                }</span>
        }

        <span class="cov0" title="0">return logger, nil</span>
}

// NewDefaultGourdianLogger creates a new Logger with all default settings.
// This is the quickest way to get started with basic logging functionality.
//
// Default configuration:
//   - Logs to "logs/gourdianlogs.log"
//   - 10MB file rotation
//   - Keeps 5 backup logs
//   - DEBUG level logging
//   - Plain text format
//   - Includes caller information
//   - Synchronous logging (no buffering)
//   - Falls back to stderr on errors
//   - No rate limiting
//
// Example:
//
//        // Simple usage with defaults:
//        logger, err := gourdianlogger.NewDefaultGourdianLogger()
//        if err != nil {
//            panic(fmt.Errorf("failed to create logger: %w", err))
//        }
//        defer logger.Close()
//
//        // Basic logging:
//        logger.Debug("Debug message")      // Will be logged
//        logger.Info("Informational message")
//        logger.Warn("Warning message")
//        logger.Error("Error message")
//
//        // Formatted logging:
//        logger.Infof("User %s logged in at %v", "john", time.Now())
//
//        // With fields (structured logging):
//        logger.InfoWithFields(map[string]interface{}{
//            "user": "john",
//            "ip": "192.168.1.1",
//        }, "User login")
//
// Note: Remember to call Close() when done to ensure all logs are flushed
// and resources are properly released.
func NewDefaultGourdianLogger() (*Logger, error) <span class="cov0" title="0">{
        config := LoggerConfig{
                Filename:        defaultFileName,
                MaxBytes:        defaultMaxBytes,
                BackupCount:     defaultBackupCount,
                LogLevel:        defaultLogLevel,
                TimestampFormat: defaultTimestampFormat,
                LogsDir:         defaultLogsDir,
                EnableCaller:    defaultEnableCaller,
                BufferSize:      defaultBufferSize,
                AsyncWorkers:    defaultAsyncWorkers,
                LogFormat:       defaultLogFormat,
                EnableFallback:  defaultEnableFallback,
                MaxLogRate:      defaultMaxLogRate,
        }
        return NewGourdianLogger(config)
}</span>

// Validate checks the LoggerConfig for invalid values.
// Returns an error if any configuration value is invalid.
func (lc *LoggerConfig) Validate() error <span class="cov0" title="0">{
        if lc.MaxBytes &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("MaxBytes cannot be negative")
        }</span>
        <span class="cov0" title="0">if lc.BackupCount &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("BackupCount cannot be negative")
        }</span>
        <span class="cov0" title="0">if lc.BufferSize &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("BufferSize cannot be negative")
        }</span>
        <span class="cov0" title="0">if lc.AsyncWorkers &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("AsyncWorkers cannot be negative")
        }</span>
        <span class="cov0" title="0">if lc.MaxLogRate &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("MaxLogRate cannot be negative")
        }</span>

        <span class="cov0" title="0">if lc.FormatStr != "" </span><span class="cov0" title="0">{
                switch strings.ToUpper(lc.FormatStr) </span>{
                case "PLAIN", "JSON":<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("invalid log format: %s", lc.FormatStr)</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (l *Logger) fileSizeRotationWorker() <span class="cov0" title="0">{
        defer l.wg.Done()
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-l.rotateChan:<span class="cov0" title="0">
                        l.fileMu.Lock()
                        if l.file != nil </span><span class="cov0" title="0">{
                                if err := l.rotateLogFiles(); err != nil </span><span class="cov0" title="0">{
                                        l.handleError(fmt.Errorf("log rotation failed: %w", err))
                                }</span>
                        }
                        <span class="cov0" title="0">l.fileMu.Unlock()</span>
                case &lt;-l.rotateCloseChan:<span class="cov0" title="0">
                        return</span>
                }
        }
}

func (l *Logger) asyncWorker() <span class="cov0" title="0">{
        defer l.wg.Done()
        batch := make([]*bytes.Buffer, 0, 100)
        ticker := time.NewTicker(100 * time.Millisecond)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case buf := &lt;-l.asyncQueue:<span class="cov0" title="0">
                        batch = append(batch, buf)
                        if len(batch) &gt;= 100 </span><span class="cov0" title="0">{
                                l.writeBatch(batch)
                                batch = batch[:0]
                        }</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if len(batch) &gt; 0 </span><span class="cov0" title="0">{
                                l.writeBatch(batch)
                                batch = batch[:0]
                        }</span>
                case &lt;-l.asyncCloseChan:<span class="cov0" title="0">
                        // Process remaining messages
                        if len(batch) &gt; 0 </span><span class="cov0" title="0">{
                                l.writeBatch(batch)
                        }</span>
                        // Drain the queue
                        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                                select </span>{
                                case buf := &lt;-l.asyncQueue:<span class="cov0" title="0">
                                        l.writeBuffer(buf)</span>
                                default:<span class="cov0" title="0">
                                        return</span>
                                }
                        }
                }
        }
}

func (l *Logger) writeFallback(message string, args ...interface{}) <span class="cov0" title="0">{
        if l.fallbackWriter == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var err error
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                _, err = fmt.Fprintf(l.fallbackWriter, message, args...)
        }</span> else<span class="cov0" title="0"> {
                _, err = fmt.Fprint(l.fallbackWriter, message)
        }</span>

        <span class="cov0" title="0">if err != nil &amp;&amp; l.errorHandler != nil </span><span class="cov0" title="0">{
                l.errorHandler(fmt.Errorf("fallback write error: %w", err))
        }</span>
}

func (l *Logger) writeBatch(buffers []*bytes.Buffer) <span class="cov0" title="0">{

        if l.paused.Load() </span><span class="cov0" title="0">{
                for _, buf := range buffers </span><span class="cov0" title="0">{
                        l.bufferPool.Put(buf) // Return buffers to pool if paused
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">l.fileMu.Lock()
        defer l.fileMu.Unlock()

        for _, buf := range buffers </span><span class="cov0" title="0">{
                if _, err := l.multiWriter.Write(buf.Bytes()); err != nil </span><span class="cov0" title="0">{
                        l.handleError(fmt.Errorf("log write error: %w", err))
                        if l.fallbackWriter != nil </span><span class="cov0" title="0">{
                                l.writeFallback("FALLBACK LOG: %s", buf.String())
                        }</span>
                }
                <span class="cov0" title="0">l.bufferPool.Put(buf)</span>
        }
}

func (l *Logger) writeBuffer(buf *bytes.Buffer) <span class="cov0" title="0">{

        if l.paused.Load() </span><span class="cov0" title="0">{
                l.bufferPool.Put(buf) // Return buffer to pool if paused
                return
        }</span>

        <span class="cov0" title="0">l.fileMu.Lock()
        defer l.fileMu.Unlock()

        if _, err := l.multiWriter.Write(buf.Bytes()); err != nil </span><span class="cov0" title="0">{
                l.handleError(fmt.Errorf("log write error: %w", err))
                if l.fallbackWriter != nil </span><span class="cov0" title="0">{
                        l.writeFallback("FALLBACK LOG: %s", buf.String())
                }</span>
        }
        <span class="cov0" title="0">l.bufferPool.Put(buf)</span>
}

func (l *Logger) handleError(err error) <span class="cov0" title="0">{
        if l.errorHandler != nil </span><span class="cov0" title="0">{
                l.errorHandler(err)
        }</span> else<span class="cov0" title="0"> if l.fallbackWriter != nil </span><span class="cov0" title="0">{
                l.writeFallback("LOGGER ERROR: %v\n", err)
        }</span>
}

func (l *Logger) formatPlain(level LogLevel, message, callerInfo string, fields map[string]interface{}) string <span class="cov0" title="0">{
        var builder strings.Builder
        builder.Grow(256) // Pre-allocate space for common case

        // Write timestamp
        builder.WriteString(time.Now().Format(l.timestampFormat))

        // Write level in brackets
        builder.WriteString(" [")
        builder.WriteString(level.String())
        builder.WriteString("] ")

        // Write caller info if available
        if callerInfo != "" </span><span class="cov0" title="0">{
                builder.WriteString(callerInfo)
                builder.WriteString(": ")
        }</span>

        // Write message
        <span class="cov0" title="0">builder.WriteString(message)

        // Write fields if available
        if len(fields) &gt; 0 </span><span class="cov0" title="0">{
                builder.WriteString(" {")
                first := true
                keys := make([]string, 0, len(fields))
                for k := range fields </span><span class="cov0" title="0">{
                        keys = append(keys, k)
                }</span>
                <span class="cov0" title="0">sort.Strings(keys) // Sort fields for consistent output

                for _, k := range keys </span><span class="cov0" title="0">{
                        if !first </span><span class="cov0" title="0">{
                                builder.WriteString(", ")
                        }</span>
                        <span class="cov0" title="0">first = false
                        builder.WriteString(k)
                        builder.WriteString("=")
                        fmt.Fprintf(&amp;builder, "%v", fields[k])</span>
                }
                <span class="cov0" title="0">builder.WriteString("}")</span>
        }

        <span class="cov0" title="0">builder.WriteString("\n")
        return builder.String()</span>
}

func (l *Logger) formatJSON(level LogLevel, message, callerInfo string, fields map[string]interface{}) string <span class="cov0" title="0">{
        logEntry := make(map[string]interface{}, len(fields)+4)
        logEntry["timestamp"] = time.Now().Format(l.timestampFormat)
        logEntry["level"] = level.String()
        logEntry["message"] = message

        if l.enableCaller &amp;&amp; callerInfo != "" </span><span class="cov0" title="0">{
                logEntry["caller"] = callerInfo
        }</span>

        <span class="cov0" title="0">for k, v := range l.config.CustomFields </span><span class="cov0" title="0">{
                logEntry[k] = v
        }</span>

        <span class="cov0" title="0">for k, v := range fields </span><span class="cov0" title="0">{
                logEntry[k] = v
        }</span>

        <span class="cov0" title="0">var jsonData []byte
        var err error

        if l.config.PrettyPrint </span><span class="cov0" title="0">{
                jsonData, err = json.MarshalIndent(logEntry, "", "  ")
        }</span> else<span class="cov0" title="0"> {
                jsonData, err = json.Marshal(logEntry)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf(`{"error":"failed to marshal log entry: %v"}`+"\n", err)
        }</span>
        <span class="cov0" title="0">return string(jsonData) + "\n"</span>
}

func (l *Logger) getCallerInfo() string <span class="cov0" title="0">{
        if !l.enableCaller </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">pc, file, line, ok := runtime.Caller(3) // Adjusted depth for logger methods
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Get function name
        <span class="cov0" title="0">fn := runtime.FuncForPC(pc)
        if fn == nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s:%d", filepath.Base(file), line)
        }</span>

        // Extract just the function name without package path
        <span class="cov0" title="0">fnName := fn.Name()
        if lastSlash := strings.LastIndex(fnName, "/"); lastSlash &gt;= 0 </span><span class="cov0" title="0">{
                fnName = fnName[lastSlash+1:]
        }</span>
        <span class="cov0" title="0">if lastDot := strings.LastIndex(fnName, "."); lastDot &gt;= 0 </span><span class="cov0" title="0">{
                fnName = fnName[lastDot+1:]
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%s:%d:%s", filepath.Base(file), line, fnName)</span>
}

func (l *Logger) log(level LogLevel, message string, fields map[string]interface{}) <span class="cov0" title="0">{
        if l.paused.Load() </span><span class="cov0" title="0">{
                return
        }</span>

        // Check rate limiting before doing any work
        <span class="cov0" title="0">if l.rateLimiter != nil </span><span class="cov0" title="0">{
                if !l.rateLimiter.Allow() </span><span class="cov0" title="0">{
                        return // Silently drop the message if rate limited
                }</span>
        }

        // Rest of the existing log method...
        <span class="cov0" title="0">var currentLevel LogLevel
        if l.dynamicLevelFn != nil </span><span class="cov0" title="0">{
                currentLevel = l.dynamicLevelFn()
        }</span> else<span class="cov0" title="0"> {
                currentLevel = LogLevel(l.level.Load())
        }</span>

        <span class="cov0" title="0">if level &lt; currentLevel </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var callerInfo string
        if l.enableCaller </span><span class="cov0" title="0">{
                callerInfo = l.getCallerInfo()
        }</span>

        <span class="cov0" title="0">var formatted string
        switch l.format </span>{
        case FormatJSON:<span class="cov0" title="0">
                formatted = l.formatJSON(level, message, callerInfo, fields)</span>
        default:<span class="cov0" title="0">
                formatted = l.formatPlain(level, message, callerInfo, fields)</span>
        }

        <span class="cov0" title="0">if l.closed.Load() </span><span class="cov0" title="0">{
                l.writeFallback("Logger closed. Message: %s", formatted)
                return
        }</span>

        <span class="cov0" title="0">if l.asyncQueue != nil </span><span class="cov0" title="0">{
                buf := l.bufferPool.Get().(*bytes.Buffer)
                buf.Reset()
                buf.WriteString(formatted)

                select </span>{
                case l.asyncQueue &lt;- buf:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0">
                        l.writeBuffer(buf)</span>
                }
        } else<span class="cov0" title="0"> {
                l.fileMu.Lock()
                defer l.fileMu.Unlock()
                if l.closed.Load() </span><span class="cov0" title="0">{
                        l.writeFallback("Logger closed. Message: %s", formatted)
                        return
                }</span>
                <span class="cov0" title="0">if _, err := l.multiWriter.Write([]byte(formatted)); err != nil </span><span class="cov0" title="0">{
                        l.handleError(fmt.Errorf("log write error: %w", err))
                        l.writeFallback("FALLBACK LOG: %s", formatted)
                }</span>
        }

        <span class="cov0" title="0">if level == FATAL </span><span class="cov0" title="0">{
                l.Flush()
                os.Exit(1)
        }</span>
}

func (l *Logger) rotateLogFiles() error <span class="cov0" title="0">{
        if l.file == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("log file not open")
        }</span>

        <span class="cov0" title="0">fileInfo, err := l.file.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get file info: %w", err)
        }</span>

        <span class="cov0" title="0">if fileInfo.Size() &lt; l.maxBytes </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Close current file
        <span class="cov0" title="0">oldFile := l.file
        if err := oldFile.Close(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to close log file: %w", err)
        }</span>

        // Create new filename with timestamp
        <span class="cov0" title="0">base := strings.TrimSuffix(l.baseFilename, ".log")
        timestamp := time.Now().Format("20060102_150405")
        backupPath := fmt.Sprintf("%s_%s.log", base, timestamp)

        // Rename current file to backup
        renameErr := os.Rename(l.baseFilename, backupPath)

        // Try to reopen the file regardless of whether rename succeeded
        file, openErr := os.OpenFile(l.baseFilename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if openErr != nil </span><span class="cov0" title="0">{
                // If we can't reopen the file, try to reopen the original file we just closed
                if renameErr == nil </span><span class="cov0" title="0">{
                        if recoveredFile, err := os.OpenFile(backupPath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644); err == nil </span><span class="cov0" title="0">{
                                l.file = recoveredFile
                                return fmt.Errorf("failed to create new log file (%v), recovered original: %w", openErr, renameErr)
                        }</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("failed to create new log file and couldn't recover original: %w", openErr)</span>
        }

        // Update logger state
        <span class="cov0" title="0">l.file = file

        // Update multiWriter with new file
        l.outputsMu.Lock()
        outputs := []io.Writer{file}
        if len(l.outputs) &gt; 1 </span><span class="cov0" title="0">{ // Keep other outputs
                outputs = append(outputs, l.outputs[1:]...)
        }</span>
        <span class="cov0" title="0">l.outputs = outputs
        l.multiWriter = io.MultiWriter(outputs...)
        l.outputsMu.Unlock()

        if renameErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to rename log file but continued logging: %w", renameErr)
        }</span>

        // Clean up old backups
        <span class="cov0" title="0">l.cleanupOldBackups()
        return nil</span>
}

func (l *Logger) cleanupOldBackups() <span class="cov0" title="0">{
        pattern := strings.TrimSuffix(l.baseFilename, ".log") + "_*.log"
        files, err := filepath.Glob(pattern)
        if err != nil || len(files) &lt;= l.backupCount </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">sort.Slice(files, func(i, j int) bool </span><span class="cov0" title="0">{
                info1, _ := os.Stat(files[i])
                info2, _ := os.Stat(files[j])
                return info1.ModTime().Before(info2.ModTime())
        }</span>)

        <span class="cov0" title="0">for _, f := range files[:len(files)-l.backupCount] </span><span class="cov0" title="0">{
                _ = os.Remove(f)
        }</span>
}

// Flush ensures all buffered log messages are written to their destinations.
// This is particularly important for asynchronous logging to ensure messages
// are written before program exit.
//
// Example:
//
//        logger.Info("Important message")
//        logger.Flush() // Ensure message is written before proceeding
func (l *Logger) Flush() <span class="cov0" title="0">{
        if l.asyncQueue != nil </span><span class="cov0" title="0">{
                // Wait for the queue to be empty
                for len(l.asyncQueue) &gt; 0 </span><span class="cov0" title="0">{
                        time.Sleep(10 * time.Millisecond)
                }</span>

                // Give async workers a moment to process any in-flight messages
                <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)</span>
        }

        // If there are any async workers, wait for them to finish current work
        <span class="cov0" title="0">if l.asyncWorkers &gt; 0 </span><span class="cov0" title="0">{
                // This gives time for any batch writes to complete
                time.Sleep(100 * time.Millisecond)
        }</span>
}

// SetLogLevel changes the minimum log level that will be processed.
// Messages below this level will be ignored.
//
// Example:
//
//        logger.SetLogLevel(gourdianlogger.WARN) // Only log WARN and above
func (l *Logger) SetLogLevel(level LogLevel) <span class="cov0" title="0">{
        l.level.Store(int32(level))
}</span>

// GetLogLevel returns the current minimum log level.
//
// Example:
//
//        if logger.GetLogLevel() &lt;= gourdianlogger.DEBUG {
//            logger.Debug("Debug message")
//        }
func (l *Logger) GetLogLevel() LogLevel <span class="cov0" title="0">{
        return LogLevel(l.level.Load())
}</span>

// SetDynamicLevelFunc sets a function that will be called for each log message
// to determine the current log level. This allows for runtime log level changes
// without requiring explicit synchronization.
//
// Example:
//
//        logger.SetDynamicLevelFunc(func() LogLevel {
//            if config.DebugMode {
//                return DEBUG
//            }
//            return INFO
//        })
func (l *Logger) SetDynamicLevelFunc(fn func() LogLevel) <span class="cov0" title="0">{
        l.dynamicLevelFn = fn
}</span>

// AddOutput adds an additional io.Writer destination for log messages.
// Useful for sending logs to multiple destinations (e.g., file and network).
//
// Example:
//
//        file, _ := os.Create("additional.log")
//        logger.AddOutput(file)
func (l *Logger) AddOutput(output io.Writer) <span class="cov0" title="0">{
        if output == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">l.outputsMu.Lock()
        defer l.outputsMu.Unlock()

        if l.closed.Load() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">l.outputs = append(l.outputs, output)
        l.multiWriter = io.MultiWriter(l.outputs...)</span>
}

// RemoveOutput removes a previously added output writer.
//
// Example:
//
//        logger.RemoveOutput(os.Stdout) // Stop logging to stdout
func (l *Logger) RemoveOutput(output io.Writer) <span class="cov0" title="0">{
        l.outputsMu.Lock()
        defer l.outputsMu.Unlock()

        if l.closed.Load() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for i, w := range l.outputs </span><span class="cov0" title="0">{
                if w == output </span><span class="cov0" title="0">{
                        l.outputs = append(l.outputs[:i], l.outputs[i+1:]...)
                        l.multiWriter = io.MultiWriter(l.outputs...)
                        return
                }</span>
        }
}

// Close cleanly shuts down the logger, flushing any buffered messages
// and closing open files. Should be called before program exit.
//
// Example:
//
//        defer logger.Close()
func (l *Logger) Close() error <span class="cov0" title="0">{
        if !l.closed.CompareAndSwap(false, true) </span><span class="cov0" title="0">{
                return nil
        }</span>

        // First stop accepting new messages
        <span class="cov0" title="0">if l.asyncCloseChan != nil </span><span class="cov0" title="0">{
                close(l.asyncCloseChan)
        }</span>
        <span class="cov0" title="0">close(l.rotateCloseChan)

        // Wait for all workers to finish processing
        done := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                l.wg.Wait()
                close(done)
        }</span>()

        // Wait with timeout
        <span class="cov0" title="0">select </span>{
        case &lt;-done:<span class="cov0" title="0"></span>
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0"></span>
                // Timeout reached, proceed with closing anyway
        }

        // Now safely close the file
        <span class="cov0" title="0">l.fileMu.Lock()
        defer l.fileMu.Unlock()

        if l.file != nil </span><span class="cov0" title="0">{
                return l.file.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// IsClosed returns true if the logger has been closed.
//
// Example:
//
//        if !logger.IsClosed() {
//            logger.Info("Still logging")
//        }
func (l *Logger) IsClosed() bool <span class="cov0" title="0">{
        return l.closed.Load()
}</span>

// Pause temporarily stops processing log messages.
// Useful for reducing logging overhead during critical sections.
//
// Example:
//
//        logger.Pause()
//        defer logger.Resume()
//        // Critical section with minimal overhead
func (l *Logger) Pause() <span class="cov0" title="0">{
        l.paused.Store(true)
}</span>

// Resume resumes processing of log messages after a Pause().
func (l *Logger) Resume() <span class="cov0" title="0">{
        l.paused.Store(false)
}</span>

// IsPaused returns true if the logger is currently paused.
func (l *Logger) IsPaused() bool <span class="cov0" title="0">{
        return l.paused.Load()
}</span>

// Debug logs a message at DEBUG level.
// Arguments are handled like fmt.Sprint().
//
// Example:
//
//        logger.Debug("Current value:", value)
func (l *Logger) Debug(v ...interface{}) <span class="cov0" title="0">{
        l.log(DEBUG, fmt.Sprint(v...), nil)
}</span>

// Info logs a message at INFO level.
// Arguments are handled like fmt.Sprint().
func (l *Logger) Info(v ...interface{}) <span class="cov0" title="0">{
        l.log(INFO, fmt.Sprint(v...), nil)
}</span>

// Warn logs a message at WARN level.
// Arguments are handled like fmt.Sprint().
func (l *Logger) Warn(v ...interface{}) <span class="cov0" title="0">{
        l.log(WARN, fmt.Sprint(v...), nil)
}</span>

// Error logs a message at ERROR level.
// Arguments are handled like fmt.Sprint().
func (l *Logger) Error(v ...interface{}) <span class="cov0" title="0">{
        l.log(ERROR, fmt.Sprint(v...), nil)
}</span>

// Fatal logs a message at FATAL level and exits the program with status 1.
// Arguments are handled like fmt.Sprint().
func (l *Logger) Fatal(v ...interface{}) <span class="cov0" title="0">{
        l.log(FATAL, fmt.Sprint(v...), nil)
        // l.Flush()
        // os.Exit(1)
}</span>

// Debugf logs a formatted message at DEBUG level.
// Arguments are handled like fmt.Sprintf().
//
// Example:
//
//        logger.Debugf("User %s logged in from %s", user, ip)
func (l *Logger) Debugf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.log(DEBUG, fmt.Sprintf(format, v...), nil)
}</span>

// Infof logs a formatted message at INFO level.
// Arguments are handled like fmt.Sprintf().
func (l *Logger) Infof(format string, v ...interface{}) <span class="cov0" title="0">{
        l.log(INFO, fmt.Sprintf(format, v...), nil)
}</span>

// Warnf logs a formatted message at WARN level.
// Arguments are handled like fmt.Sprintf().
func (l *Logger) Warnf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.log(WARN, fmt.Sprintf(format, v...), nil)
}</span>

// Errorf logs a formatted message at ERROR level.
// Arguments are handled like fmt.Sprintf().
func (l *Logger) Errorf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.log(ERROR, fmt.Sprintf(format, v...), nil)
}</span>

// Fatalf logs a formatted message at FATAL level and exits the program with status 1.
// Arguments are handled like fmt.Sprintf().
func (l *Logger) Fatalf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.log(FATAL, fmt.Sprintf(format, v...), nil)
        // l.Flush()
        // os.Exit(1)
}</span>

// DebugWithFields logs a message at DEBUG level with additional structured fields.
// Fields will be included in JSON output or as key-value pairs in text output.
//
// Example:
//
//        logger.DebugWithFields(map[string]interface{}{
//            "user": username,
//            "attempt": 3,
//        }, "Login attempt")
func (l *Logger) DebugWithFields(fields map[string]interface{}, v ...interface{}) <span class="cov0" title="0">{
        l.log(DEBUG, fmt.Sprint(v...), fields)
}</span>

// InfoWithFields logs a message at INFO level with additional structured fields.
func (l *Logger) InfoWithFields(fields map[string]interface{}, v ...interface{}) <span class="cov0" title="0">{
        l.log(INFO, fmt.Sprint(v...), fields)
}</span>

// WarnWithFields logs a message at WARN level with additional structured fields.
func (l *Logger) WarnWithFields(fields map[string]interface{}, v ...interface{}) <span class="cov0" title="0">{
        l.log(WARN, fmt.Sprint(v...), fields)
}</span>

// ErrorWithFields logs a message at ERROR level with additional structured fields.
func (l *Logger) ErrorWithFields(fields map[string]interface{}, v ...interface{}) <span class="cov0" title="0">{
        l.log(ERROR, fmt.Sprint(v...), fields)
}</span>

// FatalWithFields logs a message at FATAL level with additional structured fields
// and exits the program with status 1.
func (l *Logger) FatalWithFields(fields map[string]interface{}, v ...interface{}) <span class="cov0" title="0">{
        l.log(FATAL, fmt.Sprint(v...), fields)
        l.Flush()
        os.Exit(1)
}</span>

// DebugfWithFields logs a formatted message at DEBUG level with additional structured fields.
//
// Example:
//
//        logger.DebugfWithFields(map[string]interface{}{
//            "duration": dur,
//        }, "Process took %.2f seconds", dur.Seconds())
func (l *Logger) DebugfWithFields(fields map[string]interface{}, format string, v ...interface{}) <span class="cov0" title="0">{
        l.log(DEBUG, fmt.Sprintf(format, v...), fields)
}</span>

// InfofWithFields logs a formatted message at INFO level with additional structured fields.
func (l *Logger) InfofWithFields(fields map[string]interface{}, format string, v ...interface{}) <span class="cov0" title="0">{
        l.log(INFO, fmt.Sprintf(format, v...), fields)
}</span>

// WarnfWithFields logs a formatted message at WARN level with additional structured fields.
func (l *Logger) WarnfWithFields(fields map[string]interface{}, format string, v ...interface{}) <span class="cov0" title="0">{
        l.log(WARN, fmt.Sprintf(format, v...), fields)
}</span>

// ErrorfWithFields logs a formatted message at ERROR level with additional structured fields.
func (l *Logger) ErrorfWithFields(fields map[string]interface{}, format string, v ...interface{}) <span class="cov0" title="0">{
        l.log(ERROR, fmt.Sprintf(format, v...), fields)
}</span>

// FatalfWithFields logs a formatted message at FATAL level with additional structured fields
// and exits the program with status 1.
func (l *Logger) FatalfWithFields(fields map[string]interface{}, format string, v ...interface{}) <span class="cov0" title="0">{
        l.log(FATAL, fmt.Sprintf(format, v...), fields)
        l.Flush()
        os.Exit(1)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
