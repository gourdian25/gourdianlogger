
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>gourdianlogger: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/gourdian25/gourdianlogger/gourdianlogger.go (59.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package gourdianlogger

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "runtime"
        "sort"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "golang.org/x/time/rate"
)

type LogLevel int32

const (
        DEBUG LogLevel = iota
        INFO
        WARN
        ERROR
        FATAL
)

type LogFormat int

const (
        FormatPlain LogFormat = iota
        FormatJSON
)

var (
        defaultBackupCount           = 5
        defaultBufferSize            = 0
        defaultAsyncWorkers          = 1
        defaultMaxLogRate            = 0
        defaultEnableCaller          = true
        defaultEnableFallback        = true
        defaultLogsDir               = "logs"
        defaultLogLevel              = DEBUG
        defaultLogFormat             = FormatPlain
        defaultFileName              = "gourdianlogs"
        defaultMaxBytes        int64 = 10 * 1024 * 1024
        defaultTimestampFormat       = "2006-01-02 15:04:05.000000"
)

type LoggerConfig struct {
        BackupCount     int                    `json:"backup_count"`
        BufferSize      int                    `json:"buffer_size"`
        AsyncWorkers    int                    `json:"async_workers"`
        MaxLogRate      int                    `json:"max_log_rate"`
        EnableCaller    bool                   `json:"enable_caller"`
        EnableFallback  bool                   `json:"enable_fallback"`
        PrettyPrint     bool                   `json:"pretty_print"`
        MaxBytes        int64                  `json:"max_bytes"`
        Filename        string                 `json:"filename"`
        TimestampFormat string                 `json:"timestamp_format"`
        LogsDir         string                 `json:"logs_dir"`
        FormatStr       string                 `json:"format"`
        LogLevel        LogLevel               `json:"log_level"`
        CustomFields    map[string]interface{} `json:"custom_fields"`
        Outputs         []io.Writer            `json:"-"`
        LogFormat       LogFormat              `json:"-"`
        ErrorHandler    func(error)            `json:"-"`
}

type Logger struct {
        fileMu          sync.Mutex
        outputsMu       sync.RWMutex
        level           atomic.Int32
        baseFilename    string
        maxBytes        int64
        backupCount     int
        file            *os.File
        multiWriter     io.Writer
        timestampFormat string
        outputs         []io.Writer
        logsDir         string
        closed          atomic.Bool
        rotateChan      chan struct{}
        rotateCloseChan chan struct{}
        wg              sync.WaitGroup
        enableCaller    bool
        asyncQueue      chan *bytes.Buffer
        asyncCloseChan  chan struct{}
        asyncWorkers    int
        format          LogFormat
        fallbackWriter  io.Writer
        errorHandler    func(error)
        rateLimiter     *rate.Limiter
        config          LoggerConfig
        dynamicLevelFn  func() LogLevel
        paused          atomic.Bool
        bufferPool      sync.Pool
}

func (l LogLevel) String() string <span class="cov8" title="1">{
        switch l </span>{
        case DEBUG:<span class="cov8" title="1">
                return "DEBUG"</span>
        case INFO:<span class="cov8" title="1">
                return "INFO"</span>
        case WARN:<span class="cov8" title="1">
                return "WARN"</span>
        case ERROR:<span class="cov8" title="1">
                return "ERROR"</span>
        case FATAL:<span class="cov8" title="1">
                return "FATAL"</span>
        default:<span class="cov8" title="1">
                return "UNKNOWN"</span>
        }
}

func ParseLogLevel(level string) (LogLevel, error) <span class="cov8" title="1">{
        switch strings.ToUpper(level) </span>{
        case "DEBUG":<span class="cov8" title="1">
                return DEBUG, nil</span>
        case "INFO":<span class="cov8" title="1">
                return INFO, nil</span>
        case "WARN", "WARNING":<span class="cov8" title="1">
                return WARN, nil</span>
        case "ERROR":<span class="cov8" title="1">
                return ERROR, nil</span>
        case "FATAL":<span class="cov8" title="1">
                return FATAL, nil</span>
        default:<span class="cov8" title="1">
                return DEBUG, fmt.Errorf("invalid log level: %s", level)</span>
        }
}

func NewGourdianLogger(config LoggerConfig) (*Logger, error) <span class="cov8" title="1">{
        if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid config: %w", err)
        }</span>

        // Set defaults
        <span class="cov8" title="1">if config.MaxBytes &lt;= 0 </span><span class="cov8" title="1">{
                config.MaxBytes = defaultMaxBytes
        }</span>
        <span class="cov8" title="1">if config.BackupCount &lt;= 0 </span><span class="cov8" title="1">{
                config.BackupCount = defaultBackupCount
        }</span>
        <span class="cov8" title="1">if config.TimestampFormat == "" </span><span class="cov8" title="1">{
                config.TimestampFormat = defaultTimestampFormat
        }</span>
        <span class="cov8" title="1">if config.LogsDir == "" </span><span class="cov0" title="0">{
                config.LogsDir = defaultLogsDir
        }</span>
        <span class="cov8" title="1">if config.Filename == "" </span><span class="cov8" title="1">{
                config.Filename = "gourdianlogs"
        }</span>
        <span class="cov8" title="1">if config.AsyncWorkers &lt;= 0 &amp;&amp; config.BufferSize &gt; 0 </span><span class="cov0" title="0">{
                config.AsyncWorkers = 1
        }</span>

        <span class="cov8" title="1">config.Filename = strings.TrimSpace(strings.TrimSuffix(config.Filename, ".log"))
        if err := os.MkdirAll(config.LogsDir, 0755); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create log directory: %w", err)
        }</span>

        <span class="cov8" title="1">logPath := filepath.Join(config.LogsDir, config.Filename+".log")
        file, err := os.OpenFile(logPath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open log file: %w", err)
        }</span>

        <span class="cov8" title="1">outputs := []io.Writer{file, os.Stdout}
        if config.Outputs != nil </span><span class="cov8" title="1">{
                outputs = append(outputs, config.Outputs...)
        }</span>
        <span class="cov8" title="1">validOutputs := make([]io.Writer, 0, len(outputs))
        for _, w := range outputs </span><span class="cov8" title="1">{
                if w != nil </span><span class="cov8" title="1">{
                        validOutputs = append(validOutputs, w)
                }</span>
        }

        <span class="cov8" title="1">logger := &amp;Logger{
                baseFilename:    logPath,
                maxBytes:        config.MaxBytes,
                backupCount:     config.BackupCount,
                file:            file,
                timestampFormat: config.TimestampFormat,
                outputs:         validOutputs,
                logsDir:         config.LogsDir,
                rotateChan:      make(chan struct{}, 1),
                rotateCloseChan: make(chan struct{}),
                enableCaller:    config.EnableCaller,
                asyncWorkers:    config.AsyncWorkers,
                format:          config.LogFormat,
                errorHandler:    config.ErrorHandler,
                config:          config,
                bufferPool: sync.Pool{
                        New: func() interface{} </span><span class="cov8" title="1">{
                                return bytes.NewBuffer(make([]byte, 0, 256))
                        }</span>,
                },
        }

        <span class="cov8" title="1">if config.EnableFallback </span><span class="cov8" title="1">{
                logger.fallbackWriter = os.Stderr
        }</span>

        <span class="cov8" title="1">if config.MaxLogRate &gt; 0 </span><span class="cov0" title="0">{
                logger.rateLimiter = rate.NewLimiter(rate.Limit(config.MaxLogRate), config.MaxLogRate)
        }</span>

        <span class="cov8" title="1">logger.level.Store(int32(config.LogLevel))
        logger.multiWriter = io.MultiWriter(validOutputs...)

        logger.wg.Add(1)
        go logger.fileSizeRotationWorker()

        if config.BufferSize &gt; 0 </span><span class="cov8" title="1">{
                logger.asyncQueue = make(chan *bytes.Buffer, config.BufferSize)
                logger.asyncCloseChan = make(chan struct{})
                for i := 0; i &lt; logger.asyncWorkers; i++ </span><span class="cov8" title="1">{
                        logger.wg.Add(1)
                        go logger.asyncWorker()
                }</span>
        }

        <span class="cov8" title="1">return logger, nil</span>
}

func NewDefaultGourdianLogger() (*Logger, error) <span class="cov0" title="0">{
        config := LoggerConfig{
                Filename:        defaultFileName,
                MaxBytes:        defaultMaxBytes,
                BackupCount:     defaultBackupCount,
                LogLevel:        defaultLogLevel,
                TimestampFormat: defaultTimestampFormat,
                LogsDir:         defaultLogsDir,
                EnableCaller:    defaultEnableCaller,
                BufferSize:      defaultBufferSize,
                AsyncWorkers:    defaultAsyncWorkers,
                LogFormat:       defaultLogFormat,
                EnableFallback:  defaultEnableFallback,
                MaxLogRate:      defaultMaxLogRate,
        }
        return NewGourdianLogger(config)
}</span>

func (lc *LoggerConfig) Validate() error <span class="cov8" title="1">{
        if lc.MaxBytes &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("MaxBytes cannot be negative")
        }</span>
        <span class="cov8" title="1">if lc.BackupCount &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("BackupCount cannot be negative")
        }</span>
        <span class="cov8" title="1">if lc.BufferSize &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("BufferSize cannot be negative")
        }</span>
        <span class="cov8" title="1">if lc.AsyncWorkers &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("AsyncWorkers cannot be negative")
        }</span>
        <span class="cov8" title="1">if lc.MaxLogRate &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("MaxLogRate cannot be negative")
        }</span>

        <span class="cov8" title="1">if lc.FormatStr != "" </span><span class="cov8" title="1">{
                switch strings.ToUpper(lc.FormatStr) </span>{
                case "PLAIN", "JSON":<span class="cov8" title="1"></span>
                default:<span class="cov8" title="1">
                        return fmt.Errorf("invalid log format: %s", lc.FormatStr)</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (l *Logger) fileSizeRotationWorker() <span class="cov8" title="1">{
        defer l.wg.Done()
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-l.rotateChan:<span class="cov0" title="0">
                        l.fileMu.Lock()
                        if l.file != nil </span><span class="cov0" title="0">{
                                if err := l.rotateLogFiles(); err != nil </span><span class="cov0" title="0">{
                                        l.handleError(fmt.Errorf("log rotation failed: %w", err))
                                }</span>
                        }
                        <span class="cov0" title="0">l.fileMu.Unlock()</span>
                case &lt;-l.rotateCloseChan:<span class="cov8" title="1">
                        return</span>
                }
        }
}

func (l *Logger) asyncWorker() <span class="cov8" title="1">{
        defer l.wg.Done()
        batch := make([]*bytes.Buffer, 0, 100)
        ticker := time.NewTicker(100 * time.Millisecond)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case buf := &lt;-l.asyncQueue:<span class="cov0" title="0">
                        batch = append(batch, buf)
                        if len(batch) &gt;= 100 </span><span class="cov0" title="0">{
                                l.writeBatch(batch)
                                batch = batch[:0]
                        }</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if len(batch) &gt; 0 </span><span class="cov0" title="0">{
                                l.writeBatch(batch)
                                batch = batch[:0]
                        }</span>
                case &lt;-l.asyncCloseChan:<span class="cov8" title="1">
                        if len(batch) &gt; 0 </span><span class="cov0" title="0">{
                                l.writeBatch(batch)
                        }</span>
                        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                                select </span>{
                                case buf := &lt;-l.asyncQueue:<span class="cov8" title="1">
                                        l.writeBuffer(buf)</span>
                                default:<span class="cov8" title="1">
                                        return</span>
                                }
                        }
                }
        }
}

func (l *Logger) writeBatch(buffers []*bytes.Buffer) <span class="cov0" title="0">{
        l.fileMu.Lock()
        defer l.fileMu.Unlock()

        for _, buf := range buffers </span><span class="cov0" title="0">{
                if l.closed.Load() </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Logger closed. Message: %s", buf.String())
                        l.bufferPool.Put(buf)
                        continue</span>
                }

                <span class="cov0" title="0">if _, err := l.multiWriter.Write(buf.Bytes()); err != nil </span><span class="cov0" title="0">{
                        l.handleError(fmt.Errorf("log write error: %w", err))
                        if l.fallbackWriter != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(l.fallbackWriter, "FALLBACK LOG: %s", buf.String())
                        }</span>
                }
                <span class="cov0" title="0">l.bufferPool.Put(buf)</span>
        }
}

func (l *Logger) writeBuffer(buf *bytes.Buffer) <span class="cov8" title="1">{
        l.fileMu.Lock()
        defer l.fileMu.Unlock()

        if l.closed.Load() </span><span class="cov8" title="1">{
                fmt.Fprintf(os.Stderr, "Logger closed. Message: %s", buf.String())
                l.bufferPool.Put(buf)
                return
        }</span>

        <span class="cov0" title="0">if _, err := l.multiWriter.Write(buf.Bytes()); err != nil </span><span class="cov0" title="0">{
                l.handleError(fmt.Errorf("log write error: %w", err))
                if l.fallbackWriter != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(l.fallbackWriter, "FALLBACK LOG: %s", buf.String())
                }</span>
        }
        <span class="cov0" title="0">l.bufferPool.Put(buf)</span>
}

func (l *Logger) handleError(err error) <span class="cov8" title="1">{
        if l.errorHandler != nil </span><span class="cov8" title="1">{
                l.errorHandler(err)
        }</span> else<span class="cov0" title="0"> if l.fallbackWriter != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(l.fallbackWriter, "LOGGER ERROR: %v\n", err)
        }</span>
}

func (l *Logger) formatPlain(level LogLevel, message, callerInfo string, fields map[string]interface{}) string <span class="cov8" title="1">{
        var builder strings.Builder
        builder.Grow(256) // Pre-allocate space for common case

        builder.WriteString(time.Now().Format(l.timestampFormat))
        builder.WriteByte(' ')
        builder.WriteByte('[')
        builder.WriteString(level.String())
        builder.WriteByte(']')
        builder.WriteByte(' ')

        if callerInfo != "" </span><span class="cov8" title="1">{
                builder.WriteString(callerInfo)
                builder.WriteByte(':')
        }</span>

        <span class="cov8" title="1">builder.WriteString(message)

        if len(fields) &gt; 0 </span><span class="cov8" title="1">{
                builder.WriteString(" {")
                first := true
                for k, v := range fields </span><span class="cov8" title="1">{
                        if !first </span><span class="cov8" title="1">{
                                builder.WriteString(", ")
                        }</span>
                        <span class="cov8" title="1">first = false
                        builder.WriteString(k)
                        builder.WriteByte('=')
                        fmt.Fprintf(&amp;builder, "%v", v)</span>
                }
                <span class="cov8" title="1">builder.WriteByte('}')</span>
        }

        <span class="cov8" title="1">builder.WriteByte('\n')
        return builder.String()</span>
}

func (l *Logger) formatJSON(level LogLevel, message, callerInfo string, fields map[string]interface{}) string <span class="cov8" title="1">{
        logEntry := make(map[string]interface{}, len(fields)+4)
        logEntry["timestamp"] = time.Now().Format(l.timestampFormat)
        logEntry["level"] = level.String()
        logEntry["message"] = message

        if l.enableCaller &amp;&amp; callerInfo != "" </span><span class="cov8" title="1">{
                logEntry["caller"] = callerInfo
        }</span>

        <span class="cov8" title="1">for k, v := range l.config.CustomFields </span><span class="cov0" title="0">{
                logEntry[k] = v
        }</span>

        <span class="cov8" title="1">for k, v := range fields </span><span class="cov8" title="1">{
                logEntry[k] = v
        }</span>

        <span class="cov8" title="1">var jsonData []byte
        var err error

        if l.config.PrettyPrint </span><span class="cov0" title="0">{
                jsonData, err = json.MarshalIndent(logEntry, "", "  ")
        }</span> else<span class="cov8" title="1"> {
                jsonData, err = json.Marshal(logEntry)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf(`{"error":"failed to marshal log entry: %v"}`+"\n", err)
        }</span>
        <span class="cov8" title="1">return string(jsonData) + "\n"</span>
}

func (l *Logger) getCallerInfo() string <span class="cov0" title="0">{
        if !l.enableCaller </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">pc, file, line, ok := runtime.Caller(3)
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">fn := runtime.FuncForPC(pc)
        if fn == nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s:%d", filepath.Base(file), line)
        }</span>

        <span class="cov0" title="0">fullFnName := fn.Name()
        if lastSlash := strings.LastIndex(fullFnName, "/"); lastSlash &gt;= 0 </span><span class="cov0" title="0">{
                fullFnName = fullFnName[lastSlash+1:]
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%s:%d:%s", filepath.Base(file), line, fullFnName)</span>
}

func (l *Logger) log(level LogLevel, message string, fields map[string]interface{}) <span class="cov8" title="1">{
        if l.paused.Load() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if l.rateLimiter != nil &amp;&amp; !l.rateLimiter.Allow() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">currentLevel := LogLevel(l.level.Load())
        if l.dynamicLevelFn != nil </span><span class="cov0" title="0">{
                currentLevel = l.dynamicLevelFn()
        }</span>
        <span class="cov8" title="1">if level &lt; currentLevel </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">var callerInfo string
        if l.enableCaller </span><span class="cov0" title="0">{
                callerInfo = l.getCallerInfo()
        }</span>

        <span class="cov8" title="1">var formatted string
        switch l.format </span>{
        case FormatJSON:<span class="cov0" title="0">
                formatted = l.formatJSON(level, message, callerInfo, fields)</span>
        default:<span class="cov8" title="1">
                formatted = l.formatPlain(level, message, callerInfo, fields)</span>
        }

        <span class="cov8" title="1">if l.asyncQueue != nil </span><span class="cov8" title="1">{
                buf := l.bufferPool.Get().(*bytes.Buffer)
                buf.Reset()
                buf.WriteString(formatted)

                select </span>{
                case l.asyncQueue &lt;- buf:<span class="cov8" title="1"></span>
                default:<span class="cov0" title="0">
                        l.writeBuffer(buf)</span>
                }
        } else<span class="cov8" title="1"> {
                l.fileMu.Lock()
                defer l.fileMu.Unlock()
                if l.closed.Load() </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Logger closed. Message: %s", formatted)
                        return
                }</span>
                <span class="cov8" title="1">if _, err := l.multiWriter.Write([]byte(formatted)); err != nil </span><span class="cov8" title="1">{
                        l.handleError(fmt.Errorf("log write error: %w", err))
                        if l.fallbackWriter != nil </span><span class="cov8" title="1">{
                                fmt.Fprintf(l.fallbackWriter, "FALLBACK LOG: %s", formatted)
                        }</span>
                }
        }

        <span class="cov8" title="1">if level == FATAL </span><span class="cov0" title="0">{
                l.Flush()
                os.Exit(1)
        }</span>
}

func (l *Logger) rotateLogFiles() error <span class="cov0" title="0">{
        if l.file == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("log file not open")
        }</span>

        <span class="cov0" title="0">fileInfo, err := l.file.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get file info: %w", err)
        }</span>

        <span class="cov0" title="0">if fileInfo.Size() &lt; l.maxBytes </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">oldFile := l.file
        if err := oldFile.Close(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to close log file: %w", err)
        }</span>

        <span class="cov0" title="0">base := strings.TrimSuffix(l.baseFilename, ".log")
        timestamp := time.Now().Format("20060102_150405")
        backupPath := fmt.Sprintf("%s_%s.log", base, timestamp)

        if err := os.Rename(l.baseFilename, backupPath); err != nil </span><span class="cov0" title="0">{
                file, openErr := os.OpenFile(l.baseFilename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
                if openErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to rename log file (%v) and couldn't reopen original (%v)", err, openErr)
                }</span>
                <span class="cov0" title="0">l.file = file
                return fmt.Errorf("failed to rename log file: %w", err)</span>
        }

        <span class="cov0" title="0">file, err := os.OpenFile(l.baseFilename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create new log file: %w", err)
        }</span>

        <span class="cov0" title="0">l.file = file

        l.outputsMu.Lock()
        outputs := []io.Writer{os.Stdout, file}
        if len(l.outputs) &gt; 2 </span><span class="cov0" title="0">{
                outputs = append(outputs, l.outputs[2:]...)
        }</span>
        <span class="cov0" title="0">l.outputs = outputs
        l.multiWriter = io.MultiWriter(outputs...)
        l.outputsMu.Unlock()

        l.cleanupOldBackups()
        return nil</span>
}

func (l *Logger) cleanupOldBackups() <span class="cov0" title="0">{
        pattern := strings.TrimSuffix(l.baseFilename, ".log") + "_*.log"
        files, err := filepath.Glob(pattern)
        if err != nil || len(files) &lt;= l.backupCount </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">sort.Slice(files, func(i, j int) bool </span><span class="cov0" title="0">{
                info1, _ := os.Stat(files[i])
                info2, _ := os.Stat(files[j])
                return info1.ModTime().Before(info2.ModTime())
        }</span>)

        <span class="cov0" title="0">for _, f := range files[:len(files)-l.backupCount] </span><span class="cov0" title="0">{
                _ = os.Remove(f)
        }</span>
}

func (l *Logger) Flush() <span class="cov8" title="1">{
        if l.asyncQueue != nil </span><span class="cov0" title="0">{
                for len(l.asyncQueue) &gt; 0 </span><span class="cov0" title="0">{
                        time.Sleep(10 * time.Millisecond)
                }</span>
        }
}

func (l *Logger) SetLogLevel(level LogLevel) <span class="cov0" title="0">{
        l.level.Store(int32(level))
}</span>

func (l *Logger) GetLogLevel() LogLevel <span class="cov0" title="0">{
        return LogLevel(l.level.Load())
}</span>

func (l *Logger) SetDynamicLevelFunc(fn func() LogLevel) <span class="cov0" title="0">{
        l.dynamicLevelFn = fn
}</span>

func (l *Logger) AddOutput(output io.Writer) <span class="cov8" title="1">{
        if output == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">l.outputsMu.Lock()
        defer l.outputsMu.Unlock()

        if l.closed.Load() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">l.outputs = append(l.outputs, output)
        l.multiWriter = io.MultiWriter(l.outputs...)</span>
}

func (l *Logger) RemoveOutput(output io.Writer) <span class="cov8" title="1">{
        l.outputsMu.Lock()
        defer l.outputsMu.Unlock()

        if l.closed.Load() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">for i, w := range l.outputs </span><span class="cov8" title="1">{
                if w == output </span><span class="cov8" title="1">{
                        l.outputs = append(l.outputs[:i], l.outputs[i+1:]...)
                        l.multiWriter = io.MultiWriter(l.outputs...)
                        return
                }</span>
        }
}

func (l *Logger) Close() error <span class="cov8" title="1">{
        if !l.closed.CompareAndSwap(false, true) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">close(l.rotateCloseChan)
        if l.asyncCloseChan != nil </span><span class="cov8" title="1">{
                close(l.asyncCloseChan)
        }</span>

        <span class="cov8" title="1">l.wg.Wait()

        l.fileMu.Lock()
        defer l.fileMu.Unlock()

        if l.file != nil </span><span class="cov8" title="1">{
                return l.file.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (l *Logger) IsClosed() bool <span class="cov8" title="1">{
        return l.closed.Load()
}</span>

func (l *Logger) Pause() <span class="cov8" title="1">{
        l.paused.Store(true)
}</span>

func (l *Logger) Resume() <span class="cov8" title="1">{
        l.paused.Store(false)
}</span>

func (l *Logger) IsPaused() bool <span class="cov8" title="1">{
        return l.paused.Load()
}</span>

func (l *Logger) Debug(v ...interface{}) <span class="cov8" title="1">{
        l.log(DEBUG, fmt.Sprint(v...), nil)
}</span>

func (l *Logger) Info(v ...interface{}) <span class="cov8" title="1">{
        l.log(INFO, fmt.Sprint(v...), nil)
}</span>

func (l *Logger) Warn(v ...interface{}) <span class="cov8" title="1">{
        l.log(WARN, fmt.Sprint(v...), nil)
}</span>

func (l *Logger) Error(v ...interface{}) <span class="cov8" title="1">{
        l.log(ERROR, fmt.Sprint(v...), nil)
}</span>

func (l *Logger) Fatal(v ...interface{}) <span class="cov0" title="0">{
        l.log(FATAL, fmt.Sprint(v...), nil)
        // l.Flush()
        // os.Exit(1)
}</span>

func (l *Logger) Debugf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.log(DEBUG, fmt.Sprintf(format, v...), nil)
}</span>

func (l *Logger) Infof(format string, v ...interface{}) <span class="cov0" title="0">{
        l.log(INFO, fmt.Sprintf(format, v...), nil)
}</span>

func (l *Logger) Warnf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.log(WARN, fmt.Sprintf(format, v...), nil)
}</span>

func (l *Logger) Errorf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.log(ERROR, fmt.Sprintf(format, v...), nil)
}</span>

func (l *Logger) Fatalf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.log(FATAL, fmt.Sprintf(format, v...), nil)
        // l.Flush()
        // os.Exit(1)
}</span>

func (l *Logger) DebugWithFields(fields map[string]interface{}, v ...interface{}) <span class="cov0" title="0">{
        l.log(DEBUG, fmt.Sprint(v...), fields)
}</span>

func (l *Logger) InfoWithFields(fields map[string]interface{}, v ...interface{}) <span class="cov0" title="0">{
        l.log(INFO, fmt.Sprint(v...), fields)
}</span>

func (l *Logger) WarnWithFields(fields map[string]interface{}, v ...interface{}) <span class="cov0" title="0">{
        l.log(WARN, fmt.Sprint(v...), fields)
}</span>

func (l *Logger) ErrorWithFields(fields map[string]interface{}, v ...interface{}) <span class="cov0" title="0">{
        l.log(ERROR, fmt.Sprint(v...), fields)
}</span>

func (l *Logger) FatalWithFields(fields map[string]interface{}, v ...interface{}) <span class="cov0" title="0">{
        l.log(FATAL, fmt.Sprint(v...), fields)
        // l.Flush()
        // os.Exit(1)
}</span>

func (l *Logger) DebugfWithFields(fields map[string]interface{}, format string, v ...interface{}) <span class="cov0" title="0">{
        l.log(DEBUG, fmt.Sprintf(format, v...), fields)
}</span>

func (l *Logger) InfofWithFields(fields map[string]interface{}, format string, v ...interface{}) <span class="cov0" title="0">{
        l.log(INFO, fmt.Sprintf(format, v...), fields)
}</span>

func (l *Logger) WarnfWithFields(fields map[string]interface{}, format string, v ...interface{}) <span class="cov0" title="0">{
        l.log(WARN, fmt.Sprintf(format, v...), fields)
}</span>

func (l *Logger) ErrorfWithFields(fields map[string]interface{}, format string, v ...interface{}) <span class="cov0" title="0">{
        l.log(ERROR, fmt.Sprintf(format, v...), fields)
}</span>

func (l *Logger) FatalfWithFields(fields map[string]interface{}, format string, v ...interface{}) <span class="cov0" title="0">{
        l.log(FATAL, fmt.Sprintf(format, v...), fields)
        // l.Flush()
        // os.Exit(1)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
